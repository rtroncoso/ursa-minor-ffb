name: Build & Release (tagged)

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write     # required to create GitHub Releases

jobs:
  build-windows:
    name: Windows x64
    runs-on: windows-latest

    env:
      BIN_NAME: "Ursa Minor FFB"
      PROFILE: "release"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          components: clippy

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          cache-all-crates: true

      - name: Build (release)
        run: cargo build --locked --profile $env:PROFILE

      - name: Determine version from tag
        id: ver
        shell: bash
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          SAFE_TAG="${TAG#v}"
          echo "version=$SAFE_TAG" >> $GITHUB_OUTPUT
          # Normalize exe name (spaces -> no spaces in archive name)
          echo "bin_base=$(echo "$BIN_NAME" | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Prepare bundle
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Output dir
          $outDir = Join-Path $PWD "dist"
          if (Test-Path $outDir) { Remove-Item -Recurse -Force $outDir }
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          # Read package name from Cargo.toml
          $toml = Get-Content -Raw "Cargo.toml"
          if ($toml -match '(?ms)^\s*\[package\][\s\S]*?^\s*name\s*=\s*"(.*?)"\s*$') {
            $pkg = $Matches[1]
          } else {
            throw "Could not parse package.name from Cargo.toml"
          }

          # Candidate exe paths produced by cargo (no spaces)
          $cand1 = Join-Path "target\release" ($pkg + ".exe")                  # hyphen form
          $cand2 = Join-Path "target\release" (($pkg -replace '-', '_') + ".exe") # underscore form

          # Resolve the actual built exe
          if (Test-Path $cand1) {
            $exeIn = (Resolve-Path $cand1).Path
          } elseif (Test-Path $cand2) {
            $exeIn = (Resolve-Path $cand2).Path
          } else {
            # Fallback: first .exe in release dir
            $exeIn = (Get-ChildItem "target\release" -Filter *.exe -File | Select-Object -First 1).FullName
            if (-not $exeIn) { throw "No .exe found in target\release" }
          }

          # Pretty display name in the bundle (with spaces)
          $prettyName = "Ursa Minor FFB.exe"
          $exeOut = Join-Path $outDir $prettyName

          Copy-Item $exeIn $exeOut

          # Optional: include README, LICENSE, assets, etc.
          if (Test-Path "README.md") { Copy-Item "README.md" $outDir }
          if (Test-Path "LICENSE")   { Copy-Item "LICENSE"   $outDir }
          if (Test-Path "assets")    { Copy-Item "assets"    $outDir -Recurse }

          # Zip for release
          $zipPath = Join-Path $PWD ("ursa-minor-ffb-" + $env:GITHUB_REF_NAME + "-windows.zip")
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $outDir "*") -DestinationPath $zipPath
          Write-Host "Bundle ready: $zipPath"

      - name: Upload artifact (CI)
        uses: actions/upload-artifact@v4
        with:
          name: windows-x64-zip
          path: |
            dist/*.zip
            dist/SHA256SUMS.txt
          if-no-files-found: error

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.tag }}
          name: ${{ steps.ver.outputs.tag }}
          draft: false
          prerelease: ${{ contains(steps.ver.outputs.tag, 'rc') || contains(steps.ver.outputs.tag, 'beta') || contains(steps.ver.outputs.tag, 'alpha') }}
          files: |
            dist/*.zip
            dist/SHA256SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
